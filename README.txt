vFeed & vFeed APIThe open source cross-linked local vulnerability database vFeed is an open source naming scheme concept that provides extra structured detailed 3rd parties references for a CVE entry. While the emergence of the Open Standards helped undeniably to shape a new way to communicate about vulnerabilities , the new vFeed is adding an intelligent structured xml feed that provides effective level of information (meta-data) related to vulnerability.Key features•	Built using open source technologies•	Fully downloadable SQLite local vulnerability database •	Structured new XML format to describe vulnerabilities•	Based on major open standards CVE, CPE, CWE, CVSS..•	Support correlation with 3rd party security references (CVSS, OSVDB, OVAL…)•	Extended to support correlation with security assessment and patch vendors (Nessus, Exploit-DB, Redhat, Microsoft..)•	Simple & ready to use Python module with more than 15 methodsTarget AudiencevFeed is appropriate for:-	Penetration testers who want to analyze CVEs and gather extra information to help shape avenues to exploit vulnerabilities.-	Security auditors who want to report accurate information about findings. vFeed could be the best way to describe a CVE with attributes based on standards and 3rd party references as vendors or companies involved into standarization efforts.-	Security tools vendors / security open source developers who need to implement libraries to enumerate useful information about CVEs without wasting time to correlate and to create a proprietary database. vFeed is by far the best solution. Methods can be invoked from programs or scripts with a simple call.-	Any security hacker who is conducting researches and need a very fast and accurate way to enumerate available exploits or techniques to check a vulnerabilityThe usage
vFeed project consists of a python library to either use as a module, called from your software, or directly from command line.  In addition to the library, an SQLite database that stores different mapping tables is also provided.Bear in mind that it is always possible to develop your own API in another language. At the time of this writing, the only available library is in python. The reasons for this choice are various: 1.	Python is a quite easy to learn and I count on skilled developers and contributors to optimize and to extend the functionalities.2.	Numerous security tools are developed in python or can import adds-on in python. So it will be easy for them to implement the various methods that come with vFeedApi.3.	I’m not a programmer and always hated to write a single line of code. Besides, I always seek for the simplest way to do things with less effort. And python was a great help to make it this way.The following sample scripts will highlight the way you should use vFeedApi library. For more information about the available methods and what results they return, please refer to “vFeed API Methods” chapter. It discusses the requirements in detail.Note: For this first beta release, the only parameter provided is the CVE ID that facilitates the usage of the API.API methods callsThe vFeedAPI_calls_1.py demonstrates the ability to call a method, which will be querying the data from your own programs by importing the appropriate library. Let’s see how it operates through some examples.Ex 1: Checking for CVSS v2 scores(1) import vFeedApi(2) CVE_from_A_SCAN= "CVE-2007-6439"(3) cvssBase,cvssImpact,cvssExploit = vFeedApi.checkCVSS(CVE_from_A_SCAN)print '\t [cvss_base]:', cvssBaseprint '\t [cvss_impact]:',cvssImpactprint '\t [cvss_exploit]:',cvssExploit(1)	Import the library vFeedApi to load the appropriate methods.(2)	This is the CVE you need to check CVSS scores for(3)	Checking CVSS is mapped in vFeedApi to checkCVSS() method call. This returns 3 values: cvssBase, cvssImpact and cvssExploit. Therefore, you can use these values henceforth in your script. The values should be as following:cvssBase = 6.1cvssImpact = 6.9cvssExploit = 6.5Ex 2: Checking for Exploit-DB IDs.Let’s say we want to enumerate the PoC that we can leverage to exploit  « SQL injection vulnerability in forums.php in CMScout 1.23 a ». Any decent scanner will probably flag this vulnerability as CVE-2007-3812(1) import vFeedApi(2) CVE_Report_from_a_VAT= "CVE-2007-3812"    (3) cveEDB_id,cveEDB_file = vFeedApi.checkEDB(CVE_Report_from_a_VAT)(4) for i in range(0,len(cveEDB_id)):        print '[edb_id]:', cveEDB_id[i]        print '[edb_exploit]:', cveEDB_file[i](1)	Import the library vFeedApi to load the appropriate methods.(2)	This is a random CVE. Let’s assume it has been reported by any vulnerability scanner (or found during an assessment)(3)	Invoke the method CheckEDB which returns 2 values: cveEDB_id and cveEDB_file . They are the Exploit-DB ID and the URL link to download the exploit.(4)	This method may return a tuple containing one or multiple values. Therefore, cveEDB_id  and  cveEDB_file  are lists. So, you have to loop until you extract all values.The result may look like [edb_id]: 4182[edb_exploit]: http://www.exploit-db.com/exploits/4182


(1)	Import the library vFeedApi to load the appropriate methods.(2)	This is the CVE you need to check CVSS scores for(3)	Checking CVSS is mapped in vFeedApi to checkCVSS() method call. This returns 3 values: cvssBase, cvssImpact and cvssExploit. Therefore, you can use these values henceforth in your script. The values should be as following:cvssBase = 6.1cvssImpact = 6.9cvssExploit = 6.5Ex 2: Checking for Exploit-DB IDs.Let’s say we want to enumerate the PoC that we can leverage to exploit  « SQL injection vulnerability in forums.php in CMScout 1.23 a ». Any decent scanner will probably flag this vulnerability as CVE-2007-3812(1) import vFeedApi(2) CVE_Report_from_a_VAT= "CVE-2007-3812"    (3) cveEDB_id,cveEDB_file = vFeedApi.checkEDB(CVE_Report_from_a_VAT)(4) for i in range(0,len(cveEDB_id)):        print '[edb_id]:', cveEDB_id[i]        print '[edb_exploit]:', cveEDB_file[i](1)	Import the library vFeedApi to load the appropriate methods.(2)	This is a random CVE. Let’s assume it has been reported by any vulnerability scanner (or found during an assessment)(3)	Invoke the method CheckEDB which returns 2 values: cveEDB_id and cveEDB_file . They are the Exploit-DB ID and the URL link to download the exploit.(4)	This method may return a tuple containing one or multiple values. Therefore, cveEDB_id  and  cveEDB_file  are lists. So, you have to loop until you extract all values.The result may look like [edb_id]: 4182[edb_exploit]: http://www.exploit-db.com/exploits/4182 Call from command linevFeedAPI_calls_2.py lists and tests the available methods. It could be used as command line to check for CVE attributes and meta-data or to export information into the vFeed XML format (refer to the next chapter)[ver] vFeed Beta 1.0[info] usage: vFeedAPI_calls_2.py <API Method> <CVE id>[info] available API methods:checkCVE | checkCPE | checkCVSS | checkCWE | checkReferences | checkRISKcheckOVAL | checkNESSUS | checkEDBcheckMS | checkKB | checkAIXAPAR | checkREDHAT | checkSUSEexportXML (for exporting the vFeed XML file)The script is very easy to use. 2 parameters are mandatory: the method and the CVE ID you want to analyze.To enumerate the numerous methods already implemented, just type the script name without parameters as shown in the syntax listing above. For now, I have implemented 15 methods. The following example will help you to better understand how it works.Ex 1: Let’s check information for CVE-2007-5200 and then grab the more attributes (CPE, CVSS, risks …) as possible. For this, we will leverage different methods.(1) $ python vFeedAPI_calls_2.py checkCVE CVE-2007-5200(2)[cve_description]: hugin, as used on various operating systems including SUSE openSUSE 10.2 and 10.3, allows local users to overwrite arbitrary files via a symlink attack on the hugin_debug_optim_results.txt temporary file.[cve_published]: 2007-10-14T14:17:00.000-04:00[cve_modified]: 2008-11-15T00:00:00.000-05:00(1)	We call the script with the valid syntax. In this case: the checkCVE method and the CVE CVE-2007-5200(2)	Returned values are Description, Published and modified date. In fact, this method returns 3 values. Refer to chapter “vFeed API Methods” for more information about the methods. As you may notice, the method shows a description about SUSE vulnerability by using checkCVE. Let’s verify the vulnerable targets. For this, we will use checkCPE method.$ python vFeedAPI_calls_2.py checkCPE CVE-2007-5200[cpe_id]: cpe:/o:novell:opensuse:10.3[cpe_id]: cpe:/o:novell:opensuse:10.2[stats] CVE-2007-5200 has 2 CPEIt’s confirmed, 2 OpenSuse targets are prone to this vulnerability. Let’s go deeper and see how we can test the validity of this CVE. We will leverage the checkNESSUS to enumerate the appropriate Nessus scripts (if any). Thus can further be used to automate the scan of a large network.$ python vFeedAPI_calls_2.py checkNESSUS CVE-2007-5200[nessus_id]: 27807[nessus_file]: fedora_2007-2807.nasl[nessus_name]: Fedora 8 : hugin-0.6.1-11.fc8 (2007-2807)[nessus_family]: Fedora Local Security Checks[nessus_id]: 28154[nessus_file]: fedora_2007-2989.nasl[nessus_name]: Fedora 7 : hugin-0.6.1-11.fc7 (2007-2989)[nessus_family]: Fedora Local Security Checks[nessus_id]: 29231[nessus_file]: gentoo_GLSA-200712-01.nasl[nessus_name]: GLSA-200712-01 : Hugin: Insecure temporary file creation[nessus_family]: Gentoo Local Security Checks[nessus_id]: 27268[nessus_file]: suse_hugin-4518.nasl[nessus_name]: SuSE Security Update:  hugin creates fixed-name file in /tmp (hugin-4518)[nessus_family]: SuSE Local Security Checks[stats] CVE-2007-5200 has 4 Nessus testing script(s)Bingo, the method returns 4 Nessus scripts alongside with ids, files, names and families. You have everything to tune your scanner.[nessus_id]: 27268[nessus_file]: suse_hugin-4518.nasl[nessus_name]: SuSE Security Update:  hugin creates fixed-name file in /tmp (hugin-4518)[nessus_family]: SuSE Local Security ChecksThe customers need to understand how their systems are breakable (or not) but also the best recommendations regardless how to fix the weaknesses. Good news, vFeed comes with a set of methods to extract and correlate the patches from different sources. Let’s verify this with our example.  For now, the patch methods are 5 checkMS | checkKB | checkAIXAPAR | checkREDHAT | checkSUSEWe will leverage checkSUSE and see what it says.$ python vFeedAPI_calls_2.py checkSUSE CVE-2007-5200[SUSE_id]: SUSE-SR:2007:020[stats] CVE-2007-5200 has 1 SUSE id(s)Great, Suse has issued a patch to fix CVE-2007-5200  “SUSE-SR:2007:020”More methods to get information about the vulnerability are listed below.$ python vFeedAPI_calls_2.py checkCWE CVE-2007-5200[cwe_id]: CWE-59[stats] CVE-2007-5200 has 1 CWE$ python vFeedAPI_calls_2.py checkCVSS CVE-2007-5200 [cvss_base]: 3.3[cvss_impact]: 4.9[cvss_exploit]: 3.4$ python vFeedAPI_calls_2.py checkRISK CVE-2007-5200 [cve_severity]: Low[cve_isTopVulnerable]: False[cve_pcistatus]: PassedvFeed API methodsThe methods, except those for exporting meta-data to files, begin with “check” then followed by a more explicit name (CVE, CPE, CVSS and so on). checkCWE, you got it, will be leveraged to enumerate the CWE ids.vFeedApi available methods are-	checkCVE-	checkCVSS-	checkReferences-	checkCWE-	checkCPE-	checkRISK-	checkMS-	checkKB-	checkREDHAT-	checkSUSE-	checkAIXAPAR-	checkOVAL-	checkNESSUS-	checkEDB-	exportXML 